## 어떤 내용이 가장 기억에 남았나요?

- **구체적인 목표 설정**
    - 문제 정의가 매우 명확했다. 시간(24시간), 자원(예산), 목적(10억 페이지 크롤링 등) 등 크롤링의 범위와 한계를 명확하게 설정했다.
- **다양한 의사결정과 실험**
    - 단순히 기존 방식을 답습하지 않고, 다양한 방법을 직접 실험하고 비교하여, 현 상황과 자원에 가장 적합한 기술과 구조를 선택했다.
- **병목 예측과 반복 실험**
    - 병목이 어디에서 발생할지 미리 예측하고, 실제 테스트를 통해 검증한 뒤 결과를 반영해 설계를 계속 개선해나가는 과정을 반복했다.
- **Dano 님이 강조했던 포인트가 모두 반영**
    - 문제 정의 구체화, Fault Tolerance, 각 인스턴스별 역할 `(Fetcher = IO, Parsing = CPU)` 최적화 등 실무에서 중요한 내용을 글쓴이가 실제로 적용했다.
- **단계별 프로토타입 개발**
    - 처음에는 싱글 노드(한 대의 서버)에서 프로토타입을 제작해 정상 동작을 확인하고, 이후 점진적으로 노드 수를 확장하여 시스템을 완성했다.

---

## 어떤 의사결정이 있었나요?

- **수직 확장 → 수평 확장 구조로 전환**
    - 처음에는 한 대의 머신에 모든 역할을 올려서 성능 한계를 실험했고, 이후 노드 간 작업 분리를 통한 수평 확장 구조로 넘어갔다.
- **도메인 차단 방지를 위한 크롤링 지연(70초)**
    - 각 도메인에 대한 요청 간격을 70초로 설정하고 Redis를 통해 도메인별 fetch 순서를 관리했다.
- **샤딩 방식 도입**
    - 전체 웹사이트를 도메인 단위로 나누어, 특정 노드가 특정 도메인만 크롤링하도록 분산했다.
- **비용 최적화**
    - 데이터 저장소로 비용이 비싼 S3 대신 저장공간이 넉넉한 i7i.4xlarge 인스턴스의 로컬 스토리지를 사용했다.
- **Fetcher:Parser 비율 조정(3:2)**
    - IO 작업(fetching)과 CPU 작업(parsing)의 특성을 고려하여 각 노드 내 fetcher와 parser 프로세스의 비율을 3:2로 조절했다.
- **파서 라이브러리 선택(lxml → Lexbor)**
    - 기존보다 약 30배 빠른 최신 HTML5 파서(Lexbor, selectolax 래퍼)로 교체해 파싱 병목을 크게 개선했다.
- **메모리 이슈 대응**
    - Redis의 메모리 초과 문제를 해결하기 위해 HTML 콘텐츠를 250KB까지만 저장(나머지는 잘라냄).
- **노드를 12개로 설정**
    
    샤딩(Shard) 구조로 작업을 분산할 때, 노드 단위로 너무 잘게 쪼개면 다음과 같은 문제 발생
    
    - 인기 많은 도메인을 담당하는 노드는 방문할 링크가 계속 쏟아져 일이 끝나지 않는 반면, 비인기 도메인(트래픽이 적은 사이트)을 맡은 노드는 금방 모든 작업을 마치고 대기 상태에 들어간다.
    - 이처럼 노드마다 작업량의 불균형이 심해지면 전체 클러스터의 효율이 떨어지고, 노드가 아무리 많아도 가장 오래 일하는 노드 때문에 전체 작업이 지연된다.
    - 따라서 효율을 극대화하려면, 각 노드에 인기 도메인과 비인기 도메인이 골고루 섞이도록 배분하고, 노드의 개수 역시 적절하게 유지해야 한다.